<!DOCTYPE html>
<html lang="en-GB">
    <head>
		<meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Factory: Tutorial</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="extra.js"></script>
    </head>
    <body>
		<header>
            <nav class="navbar navbar-inverse" role="navigation">
                <div class="container">
                    <div class="navbar-header">
    					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navrow1" aria-expanded="false" aria-controls="navbar">
            				<span class="sr-only">Toggle navigation</span>
            				<span class="icon-bar"></span>
            				<span class="icon-bar"></span>
            				<span class="icon-bar"></span>
            			</button>
                        <a class="navbar-brand" href="index.html">Factory </a>
                    </div>
                </div>
            </nav>
		</header>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="container">
                <div class="content" id="content">
							<article>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Every Factory application is composed of computational <a class="el" href="structfactory_1_1Kernel.html"><em> kernels</em></a> &mdash; self-contained objects which store data and have routines to process it. In each routine a kernel may create any number of <em>subordinates</em> to decompose application into smaller parts. Some kernels can be transferred to another cluster node to make application distributed. An application exits when there are no kernels left to process.</p>
<p>Kernels are processed by <a class="el" href="structfactory_1_1Server__with__pool.html"><em>pipelines</em></a> &mdash; kernel queues with processing threads attached. Each device has its own pipeline (there is a pipeline for CPU, I/O device and NIC) which allows them to work in parallel: process one part of data with CPU pipeline and simultaneously write another one with disk pipeline. Every pipeline work until application exit.</p>
<p>Each programme begins with starting all necessary pipelines and sending the main kernel to one of the them. After that programme execution resembles that of sequential programme with each nested call to a procedure replaced with construction of a subordinate kernel and sending it to appropriate pipeline. The difference is that pipelines process kernels <em>asynchronously</em>, so procedure code is decomposed into <a class="el" href=""><code>act()</code></a> routine which constructs subordinates and <a class="el" href=""><code>react()</code></a> routine which processes results they return.</p>
<h1><a class="anchor" id="api"></a>
Developing distributed applications</h1>
<p>The first step is to decide which pipelines your programme needs. Most probably these are standard</p><ul>
<li><a class="el" href="structfactory_1_1CPU__server.html">CPU pipeline</a>,</li>
<li><a class="el" href="structfactory_1_1IO__server.html">I/O pipeline</a>,</li>
<li><a class="el" href="structfactory_1_1NIC__server.html">NIC pipeline</a> and</li>
<li><a class="el" href="structfactory_1_1Timer__server.html">Timer pipeline</a> (for periodic and schedule-based execution of kernels).</li>
</ul>
<p>Standard pipelines for all devices except NIC are initialised in <code><a class="el" href="factory_8hh_source.html">factory/factory.hh</a></code> header. To initialise NIC pipeline you need to tell it which pipeline is local and which one is remote. The following code snippet shows the usual way of doing this.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;factory/factory.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;factory/cpu_server.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;factory/timer_server.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;factory/nic_server.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;factory/kernel.hh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacefactory.html">factory</a> {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structRouter.html">Router</a> {</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span></div>
<div class="line">        send_local(Kernel* rhs) {</div>
<div class="line">            local_server.send(rhs);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span></div>
<div class="line">        send_remote(Kernel*);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span></div>
<div class="line">        forward(<span class="keyword">const</span> Kernel_header&amp; hdr, <a class="code" href="structsys_1_1basic__packetstream.html">sys::packetstream</a>&amp; istr) {</div>
<div class="line">            assert(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    NIC_server&lt;Kernel, sys::socket, Router&gt; remote_server;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    Router::send_remote(Kernel* rhs) {</div>
<div class="line">        remote_server.send(rhs);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>The second step is to subclass <a class="el" href="structfactory_1_1Kernel.html"><code>factory::Kernel</code></a> and implement <code>act()</code> and <code>react()</code> member functions for each sequential stage of your programme and for parallel parts of each stage.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>My_app: <span class="keyword">public</span> <a class="code" href="structfactory_1_1Kernel.html">factory::Kernel</a> {</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    act() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        factory::commit(local_server, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    react(<a class="code" href="structfactory_1_1Kernel.html">factory::Kernel</a>*) {</div>
<div class="line">        <span class="comment">// not needed for such a simple programme</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Even if your programme does not have parallel parts, its performance may still increase by constructing a separate instance of a kernel for each input file. For example, to make a programme that searches files for matching pattern (<code>grep</code> command in UNIX) parallel it is sufficient to construct a kernel for each file and send all of them to CPU pipeline. A better way is to construct a separate kernel to read portions of the files via I/O pipeline and for each portion construct and send new kernel to CPU pipeline to process it in parallel.</dd></dl>
<p>Finally, you need to start every pipeline and send the main kernel to the local one via <a class="el" href="">factory::upstream</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">using</span> factory::local_server;</div>
<div class="line">    <span class="keyword">using</span> factory::remote_server;</div>
<div class="line">    <a class="code" href="structfactory_1_1Terminate__guard.html">factory::Terminate_guard</a> g0;</div>
<div class="line">    <a class="code" href="structfactory_1_1Server__guard.html">factory::Server_guard&lt;decltype(local_server)&gt;</a> g1(local_server);</div>
<div class="line">    <a class="code" href="structfactory_1_1Server__guard.html">factory::Server_guard&lt;decltype(remote_server)&gt;</a> g2(remote_server);</div>
<div class="line">    factory::upstream(local_server, <span class="keyword">nullptr</span>, <span class="keyword">new</span> My_app);</div>
<div class="line">    <span class="keywordflow">return</span> factory::wait_and_return();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Use <a class="el" href="">factory::commit</a> to return the kernel to its parent and reclaim system resources.</p>
<h1><a class="anchor" id="failover"></a>
Automatic failure handling</h1>
<p>In general, there are two types of failures occurring in any hierarchical distributed system:</p>
<ul>
<li>failure of a <em>subordinate</em> node &mdash; a node which connects only to its principal and no other node &mdash; and</li>
<li>failure of a <em>principal</em> node &mdash; a node with multiple connections.</li>
</ul>
<p>In Factory the "node" refers both to a cluster node and to a kernel, failures of which are handled differently.</p>
<h2><a class="anchor" id="kernel-failures"></a>
Handling kernel failures</h2>
<p>Since any subordinate kernel is part of a hierarchy the simplest method of handling its failure is to let its principal restart it on a healthy cluster node. Factory does this automatically for any kernel that has parent. This approach works well unless your hierarchy is deep and require restarting a lot of kernels upon a failure; however, this approach does not work for the main kernel &mdash; the first kernel of an application that does not have a parent.</p>
<p>In case of the main kernel failure the only option is to keep a copy of it on some other cluster node and restore from it when the former node fails. Factory implements this for any kernel with the <a class="el" href="structfactory_1_1Basic__kernel.html#a7f0c5992c9dc1cf104d965cd577a35eea71bde718562728b5a1fa1423c1244b23">factory::Basic_kernel::Flag::carries_parent</a> flag set, but the approach works only for those principal kernels that have only one subordinate at a time (extending algorithm to cover more cases is one of the goals of ongoing research).</p>
<p>At present, a kernel is considered failed when a node to which it was sent fails, and a node is considered failed when the corresponding connection closes unexpectedly. At the moment, there is no mechanism that deals with unreliable connections other than timeouts configured in underlying operating system.</p>
<h2><a class="anchor" id="node-failures"></a>
Handling cluster node failures</h2>
<p>Cluster node failures are much simpler to mitigate: there is no state to be lost and the only invariant that should be preserved in a cluster is connectivity of nodes. All nodes should "know" each other and be able to establish arbitrary connections between each other; in other words, nodes should be able to <em>discover</em> each other. Factory implements this functionality without distributed consensus algorithm: the framework builds tree hierarchy of nodes using IP addresses and pre-set fan-out value to rank nodes. Using this algorithm a node computes IP address of its would-be principal and tries to connect to it; if the connection fails it tries another node from the same or higher level of tree hierarchy. If it reaches the root of the tree and no node responds, it becomes the root node. This algorithm is used both during node bootstrap phase and upon a failure of any principal.</p>
<h1><a class="anchor" id="hierarchy"></a>
Hierarchical architecture</h1>
<p>At high-level Factory framework is composed of multiple layers:</p>
<ul>
<li>physical layer (fully-connected servers and network switches),</li>
<li>middleware layer (hierarchy of nodes),</li>
<li>application layer (hierarchy of kernels).</li>
</ul>
<p>Load balancing is implemented by superimposing hierarchy of kernels on the hierarchy of nodes: When a node pipelines are overflown by kernels some of them may be "spilled" to subordinate nodes (planned feature), much like water flows from the top of a cocktail pyramid down to its bottom when volume of glasses in the current layer is to small to hold it.</p>
<h1><a class="anchor" id="bottomup"></a>
Bottom-up design</h1>
<p>Factory framework uses <a href="http://www.paulgraham.com/progbot.html">bottom-up</a> source code development approach which means we create low-level abstractions to simplify high-level code and make it clean and readable. There are two layers of abstractions:</p>
<ul>
<li><a class="el" href="namespacesys.html">operating system layer</a>, which contains thin C++ wrappers for POSIX and Linux system calls and data structures, and</li>
<li><a class="el" href="namespacestdx.html">generic C++ abstractions layer</a>, which consists of template routines and classes (e.g. iterators, I/O stream manipulators, guard objects etc.) that are missing in STL.</li>
</ul>
<p>From developer perspective it is unclear which layer is the bottom one, but still we would like to separate them via <a href="https://erdani.com/publications/xp2000.pdf">policy-based programming</a> and <a href="http://erdani.com/publications/traits.html">traits classes</a>.</p>
<p>It is easy to extend Factory source code base: just put all system-related abstractions into <code>sys</code> directory, all generic structures and functions into <code>stdx</code> directory and all framework-specific abstractions into <code>factory</code> directory. </p>
</div></div><!-- contents -->

</article>
</div>
</div>
<footer>
<address class="footer">
<small>
Generated by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.10
</small>
</address>
</footer>
</body>
</html>
